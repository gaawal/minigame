<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>3D 轨迹球 · 迷你游戏（含护盾 & 追踪敌人）</title>

  <!-- Tailwind (使用 jsDelivr，兼容中国) -->
 <!-- 最新版本 -->
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/dist/tailwind.min.css" rel="stylesheet">
<!-- 最新版本 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
<!-- Vue 3 最新版本 -->
<script src="https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.min.js"></script>
<!-- 或指定版本 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
<!-- 生产环境推荐指定版本 -->
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/dist/tailwind.min.css" rel="stylesheet">

  <!-- 少量内联样式，确保 canvas 可见 -->
  <style>
    html,body,#app { height:100%; margin:0; background: linear-gradient(180deg,#041424 0%, #00121a 100%); color: #fff; -webkit-font-smoothing:antialiased; }
    #game-wrap { height:100vh; width:100vw; display:flex; align-items:flex-start; justify-content:center; position:relative; overflow:hidden; }
    #canvas-container { width:100%; max-width:720px; height:100vh; position:relative; z-index:1; display:flex; align-items:center; justify-content:center; }
    canvas { display:block; width:100% !important; height:100% !important; }
    .hud { position:absolute; top:12px; left:12px; right:12px; display:flex; justify-content:space-between; gap:10px; z-index:40; pointer-events:none; }
    .hud .panel { pointer-events:auto; background: rgba(2,6,23,0.55); padding:8px 12px; border-radius:10px; backdrop-filter: blur(6px); }
    #touchpad { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); width:220px; height:120px; z-index:40; display:flex; flex-direction:column; align-items:center; gap:8px; }
    #joystick { width:120px; height:120px; border-radius:999px; background: rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; }
    #knob { width:44px; height:44px; border-radius:999px; background: rgba(255,255,255,0.12); touch-action:none; transform:translate(0,0); transition: transform 0.06s linear; }
    .center-panel { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:50; pointer-events:auto; }
    .btn { cursor:pointer; }
    /* 游戏结束/启动遮罩 */
    .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; }
    .small-hint { font-size:12px; opacity:0.9; }
  </style>
</head>
<body>
  <div id="app">
    <div id="game-wrap">
      <!-- HUD -->
      <div class="hud">
        <div class="panel flex items-center gap-4">
          <div>
            <div class="text-xs">分数</div>
            <div class="text-2xl font-bold">{{ score }}</div>
          </div>
          <div>
            <div class="text-xs">生命</div>
            <div class="text-lg font-medium">❤ x {{ livesDisplay }}</div>
          </div>
          <div>
            <div class="text-xs">护盾</div>
            <div class="text-lg font-medium" :class="{'text-emerald-300': shieldActive}">{{ shieldActive ? 'ON' : 'OFF' }}</div>
          </div>
        </div>

        <div class="panel flex items-center gap-3">
          <div class="text-xs">等级</div>
          <div class="text-xl font-semibold">{{ level }}</div>
        </div>

        <div class="panel flex items-center gap-2">
          <button @click="togglePause" class="px-3 py-1 rounded bg-slate-800/60 hover:bg-slate-700/80 btn"> {{ running ? '暂停' : '继续' }} </button>
          <button @click="restart" class="px-3 py-1 rounded bg-red-700/60 hover:bg-red-600/80 btn">重启</button>
        </div>
      </div>

      <!-- three canvas container -->
      <div id="canvas-container"></div>

      <!-- joystick for non-gyro -->
      <div id="touchpad" v-show="!gyroAvailable && started">
        <div id="joystick"><div id="knob"></div></div>
        <div class="small-hint">滑动控制球（当无陀螺仪时）</div>
      </div>

      <!-- start overlay -->
      <div v-if="!started" class="overlay">
        <div class="bg-slate-900/80 p-6 rounded-lg text-center">
          <h2 class="text-2xl font-bold mb-2">3D 轨迹球 · 迷你游戏</h2>
          <p class="mb-4">摇动手机（或滑动摇杆）控制球，躲避敌人并收集加分点。新增：护盾道具 & 追踪敌人。</p>
          <div class="flex gap-3 justify-center">
            <button @click="startAndRequestSensor" class="px-4 py-2 rounded bg-emerald-600 hover:bg-emerald-500 btn">开始（尝试授权陀螺仪）</button>
            <button @click="startWithoutGyro" class="px-4 py-2 rounded bg-slate-700 hover:bg-slate-600 btn">开始（不授权）</button>
          </div>
        </div>
      </div>

      <!-- game over overlay -->
      <div v-if="gameOver" class="overlay">
        <div class="bg-black/70 p-6 rounded-lg text-center">
          <h2 class="text-3xl font-bold mb-2">游戏结束</h2>
          <p class="mb-4">最终分数：<span class="font-mono">{{ score }}</span></p>
          <div class="flex gap-3 justify-center">
            <button @click="restart" class="px-4 py-2 rounded bg-amber-500 hover:bg-amber-400 btn">再来一次</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Library loader (jsDelivr 优先；若失败可改用其它 CDN) -->
  <script>
    // 动态加载脚本并检测 window 全局对象是否就绪
    function loadScript(url, testName){
      return new Promise((resolve, reject) => {
        // already loaded?
        if (testName && window[testName]) { resolve(); return; }
        const s = document.createElement('script');
        s.src = url;
        s.async = true;
        s.onload = () => {
          // small delay to let it set globals
          setTimeout(()=>resolve(), 20);
        };
        s.onerror = () => reject(new Error('Load failed: ' + url));
        document.head.appendChild(s);
      });
    }

    // 加载 Vue 和 THREE（优先 jsdelivr）
    (async ()=>{
      try {
        await loadScript('https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js', 'Vue');
      } catch(e) {
        console.warn('jsdelivr vue failed, try unpkg', e);
        await loadScript('https://unpkg.com/vue@3/dist/vue.global.prod.js', 'Vue');
      }
      try {
        await loadScript('https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js', 'THREE');
      } catch(e) {
        console.warn('jsdelivr three failed, try unpkg', e);
        await loadScript('https://unpkg.com/three@0.161.0/build/three.min.js', 'THREE');
      }
      // now mount app
      initApp();
    })();
  </script>

  <!-- 主程序（等库加载完） -->
  <script>
  function initApp(){
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          score: 0,
          lives: 3,
          level: 1,
          running: true,
          started: false,
          gameOver: false,
          gyroAvailable: false,
          shieldActive: false,
          shieldTimer: 0,
          inputX: 0, inputZ: 0,
        }
      },
      computed: {
        livesDisplay() {
          // 显示整数或一位小数（碰撞时可能扣0.5）
          return Math.max(0, Math.round(this.lives*10)/10);
        }
      },
      methods: {
        togglePause(){ this.running = !this.running; },
        restart(){ location.reload(); },
        async startAndRequestSensor(){
          // iOS 13+ 需要授权
          try {
            if (typeof DeviceMotionEvent !== 'undefined' && DeviceMotionEvent.requestPermission) {
              const res = await DeviceMotionEvent.requestPermission();
              this.gyroAvailable = (res === 'granted');
            } else {
              this.gyroAvailable = true;
            }
          } catch(e){ this.gyroAvailable = false; }
          this.started = true;
        },
        startWithoutGyro(){ this.gyroAvailable = false; this.started = true; },

        initThreeGame() {
          const self = this;
          const container = document.getElementById('canvas-container');
          // 清空 container
          container.innerHTML = '';

          const W = Math.min(window.innerWidth, 900);
          const H = window.innerHeight;

          // renderer
          const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
          renderer.setSize(W,H);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          container.appendChild(renderer.domElement);
          renderer.domElement.style.zIndex = 10;
          renderer.domElement.style.touchAction = 'none';

          // scene & camera
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x00121a);

          const camera = new THREE.PerspectiveCamera(52, W/H, 0.1, 2000);
          camera.position.set(0, 28, 46);
          camera.lookAt(0,0,0);

          // lights
          const hemi = new THREE.HemisphereLight(0xbfeeff, 0x072232, 0.9);
          scene.add(hemi);
          const dir = new THREE.DirectionalLight(0xffffff, 0.9);
          dir.position.set(10,20,10);
          scene.add(dir);

          // ground
          const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(44, 1400, 4, 80),
            new THREE.MeshStandardMaterial({ color:0x052233, roughness:0.9, metalness:0.05, side:THREE.DoubleSide })
          );
          ground.rotation.x = -Math.PI/2;
          ground.position.y = -6;
          scene.add(ground);

          // borders
          const borderMat = new THREE.MeshStandardMaterial({ color:0x063447 });
          const left = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 1400), borderMat);
          left.position.set(-22, -2, 0);
          const right = left.clone();
          right.position.set(22, -2, 0);
          scene.add(left); scene.add(right);

          // player
          const player = {
            mesh: null, radius:1.6, pos: new THREE.Vector3(0, -4, 20), vel: new THREE.Vector3(0,0,0), power:1, mass:1
          };
          const pMat = new THREE.MeshStandardMaterial({ color:0x66ffdd, roughness:0.25, emissive:0x003f3f, emissiveIntensity:0.25 });
          const pMesh = new THREE.Mesh(new THREE.SphereGeometry(player.radius, 28, 22), pMat);
          scene.add(pMesh); player.mesh = pMesh;

          // shield visual (semi-transparent sphere)
          const shieldMat = new THREE.MeshStandardMaterial({ color:0x6ff0c2, transparent:true, opacity:0.15, side:THREE.DoubleSide });
          const shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(player.radius*1.6, 20, 16), shieldMat);
          shieldMesh.visible = false;
          scene.add(shieldMesh);

          // bounds
          const bounds = { minX:-18, maxX:18, minZ:-300, maxZ:150 };

          // entities
          const enemies = [], pickups = [], obstacles = [];

          // spawn params
          let lastTime = performance.now();
          let spawnTimer = 0, difficultyTimer = 0;
          let spawnInterval = 1200;
          let baseSpeed = 0.06;
          let forwardScroll = 0;

          // helper spawners
          function createEnemy(zPos, type='normal') {
            // type: 'normal' | 'homing'
            const r = 1.1 + Math.random()*0.9;
            const geo = new THREE.SphereGeometry(r, 14, 12);
            const color = (type==='homing') ? 0xffb86b : 0xff5a5a;
            const mat = new THREE.MeshStandardMaterial({ color, roughness:0.4, emissive: (type==='homing'?0x332200:0x220000), emissiveIntensity:0.12 });
            const m = new THREE.Mesh(geo, mat);
            const x = (Math.random()*2-1)*16;
            m.position.set(x, -4, zPos);
            scene.add(m);
            enemies.push({ mesh:m, radius:r, speed: baseSpeed + Math.random()*0.06, type });
          }
          function createPickup(zPos, kind='score') {
            // kind: score | shield
            const r = (kind==='shield') ? 0.9 : 0.6;
            const geo = new THREE.SphereGeometry(r, 12, 10);
            const mat = new THREE.MeshStandardMaterial({ color: kind==='shield' ? 0x7ae6ff : 0x7af28f, emissive:0x224422 });
            const m = new THREE.Mesh(geo, mat);
            const x = (Math.random()*2-1)*16;
            m.position.set(x, -2.2, zPos);
            scene.add(m);
            pickups.push({ mesh:m, radius:r, kind, value: (kind==='shield'?0: (10 + Math.floor(Math.random()*15))) });
          }
          function createObstacle(zPos) {
            const w = 2 + Math.random()*4;
            const h = 1.2 + Math.random()*3;
            const d = 1.5 + Math.random()*3;
            const geo = new THREE.BoxGeometry(w,h,d);
            const mat = new THREE.MeshStandardMaterial({ color:0x345a66, roughness:0.95 });
            const m = new THREE.Mesh(geo, mat);
            const x = (Math.random()*2-1) * 14;
            m.position.set(x, -3.5, zPos);
            scene.add(m);
            obstacles.push({ mesh: m, radius: Math.max(w,h,d)/2 });
          }

          // initial fill
          for (let i=0;i<10;i++){
            const z = -i*10 + 40;
            if (Math.random() < 0.4) createPickup(z, Math.random()<0.12 ? 'shield' : 'score');
            if (Math.random() < 0.45) createEnemy(z - 10*Math.random(), Math.random()<0.18 ? 'homing' : 'normal');
            if (Math.random() < 0.2) createObstacle(z - 5*Math.random());
          }

          // collision util
          function sphereCollision(aPos,aR,bPos,bR){ return aPos.distanceTo(bPos) < (aR + bR); }

          // joystick setup
          let knob = null, knobOrigin = null, dragging = false;
          const maxKnob = 44;
          function setupJoystick() {
            knob = document.getElementById('knob');
            if (!knob) return;
            knob.style.touchAction='none';
            knob.addEventListener('pointerdown', ev=>{
              knob.setPointerCapture(ev.pointerId);
              dragging = true;
              if (!knobOrigin) {
                const rect = knob.parentElement.getBoundingClientRect();
                knobOrigin = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
              }
            });
            knob.addEventListener('pointermove', ev=>{
              if (!dragging) return;
              const dx = ev.clientX - knobOrigin.x;
              const dy = ev.clientY - knobOrigin.y;
              const mag = Math.min(maxKnob, Math.hypot(dx,dy));
              const ang = Math.atan2(dy, dx);
              const nx = Math.cos(ang) * mag;
              const ny = Math.sin(ang) * mag;
              knob.style.transform = `translate(${nx}px, ${ny}px)`;
              self.inputX = Math.max(-1, Math.min(1, nx / maxKnob));
              self.inputZ = Math.max(-1, Math.min(1, -ny / maxKnob));
            });
            const up = ()=>{
              dragging = false; if (!knob) return;
              knob.style.transform = 'translate(0,0)';
              self.inputX = 0; self.inputZ = 0;
            };
            knob.addEventListener('pointerup', up);
            knob.addEventListener('pointercancel', up);
            knob.addEventListener('lostpointercapture', up);
          }
          setupJoystick();

          // Device orientation
          let devGamma = 0, devBeta = 0;
          window.addEventListener('deviceorientation', e=>{
            if (!self.started || !self.gyroAvailable) return;
            devGamma = e.gamma || 0; devBeta = e.beta || 0;
            const gx = Math.max(-45, Math.min(45, devGamma))/45;
            const gz = Math.max(-45, Math.min(45, devBeta-5))/45;
            self.inputX = gx; self.inputZ = gz;
          });

          // touch double-tap dash
          let lastTap = 0;
          renderer.domElement.addEventListener('touchstart', ()=>{
            const t = performance.now();
            if (t - lastTap < 280) {
              player.vel.z -= 0.6;
            }
            lastTap = t;
          }, {passive:true});

          // main loop
          function tick(now) {
            const dt = Math.min(40, now - lastTime)/1000;
            lastTime = now;
            if (self.started && self.running && !self.gameOver) {
              // difficulty
              difficultyTimer += dt*1000;
              if (difficultyTimer > 8000) {
                difficultyTimer = 0;
                spawnInterval = Math.max(360, spawnInterval - 70);
                baseSpeed += 0.01;
                self.level += 1;
              }

              // input -> acceleration
              const accelScale = 18.0 * (0.4 + player.power*0.25);
              const ax = self.inputX * accelScale;
              const az = self.inputZ * accelScale;
              const drag = 3.2;
              player.vel.x += (ax - player.vel.x*drag) * dt;
              player.vel.z += (az - player.vel.z*drag) * dt;

              const maxSpeed = 12 + player.power*6;
              if (player.vel.length() > maxSpeed) player.vel.setLength(maxSpeed);
              player.pos.addScaledVector(player.vel, dt);

              // bounds
              if (player.pos.x < bounds.minX + player.radius) { player.pos.x = bounds.minX + player.radius; player.vel.x *= -0.35; }
              if (player.pos.x > bounds.maxX - player.radius) { player.pos.x = bounds.maxX - player.radius; player.vel.x *= -0.35; }
              if (player.pos.z < bounds.minZ + player.radius) { player.pos.z = bounds.minZ + player.radius; player.vel.z *= -0.35; }
              if (player.pos.z > bounds.maxZ - player.radius) { player.pos.z = bounds.maxZ - player.radius; player.vel.z *= -0.35; }

              // apply to mesh
              player.mesh.position.copy(player.pos);
              shieldMesh.position.copy(player.pos);
              shieldMesh.visible = self.shieldActive;

              // move entities toward +z (downwards visually)
              const lists = [enemies, pickups, obstacles];
              for (const g of lists) {
                for (let i=g.length-1;i>=0;i--) {
                  const it = g[i];
                  // homing enemy behavior
                  if (it.type === 'homing' && Math.random() < 0.9) {
                    // small adjustment toward player in x direction
                    const dir = new THREE.Vector3().subVectors(player.pos, it.mesh.position);
                    dir.y = 0;
                    dir.setLength( (0.6 + Math.random()*0.6) * dt * 12 );
                    it.mesh.position.add(dir);
                  }
                  // everyone moves forward (toward +z)
                  it.mesh.position.z += ((baseSpeed + (Math.random()*0.03)) * 60) * dt;
                  if (it.mesh.position.z > bounds.maxZ + 80) {
                    scene.remove(it.mesh); g.splice(i,1);
                    continue;
                  }
                }
              }

              // spawn new
              spawnTimer += dt*1000;
              if (spawnTimer > spawnInterval) {
                spawnTimer = 0;
                const zSpawn = bounds.minZ + 30;
                const r = Math.random();
                if (r < 0.45) createEnemy(zSpawn, Math.random() < Math.min(0.4, 0.06 + self.level*0.02) ? 'homing' : 'normal');
                else if (r < 0.8) createPickup(zSpawn, Math.random()<0.12 ? 'shield' : 'score');
                else createObstacle(zSpawn);
              }

              // pickups collision
              for (let i=pickups.length-1;i>=0;i--) {
                const p = pickups[i];
                if (sphereCollision(player.pos, player.radius, p.mesh.position, p.radius)) {
                  if (p.kind === 'shield') {
                    // activate shield
                    self.shieldActive = true; self.shieldTimer = 6.0; // seconds
                  } else {
                    self.score += p.value;
                    player.power = Math.min(6, player.power + 0.12);
                  }
                  scene.remove(p.mesh); pickups.splice(i,1);
                }
              }

              // enemies collision
              for (let i=enemies.length-1;i>=0;i--) {
                const en = enemies[i];
                if (sphereCollision(player.pos, player.radius, en.mesh.position, en.radius)) {
                  // if shield active -> reduce effect
                  if (self.shieldActive) {
                    // shield absorbs, maybe get slight push
                    player.vel.add(new THREE.Vector3().subVectors(player.pos, en.mesh.position).setLength(2));
                    self.shieldTimer = Math.max(0, self.shieldTimer - 1.2); // shield diminishes
                    // remove enemy
                    scene.remove(en.mesh); enemies.splice(i,1);
                  } else {
                    self.lives -= 1;
                    const push = new THREE.Vector3().subVectors(player.pos, en.mesh.position).setLength(4);
                    player.vel.add(push);
                    scene.remove(en.mesh); enemies.splice(i,1);
                    if (self.lives <= 0) {
                      self.gameOver = true; self.running = false;
                    }
                  }
                }
              }

              // obstacle collision (simplified)
              for (let i=obstacles.length-1;i>=0;i--) {
                const ob = obstacles[i];
                if (sphereCollision(player.pos, player.radius, ob.mesh.position, ob.radius)) {
                  if (self.shieldActive) {
                    // shield reduces damage
                    self.shieldTimer = Math.max(0, self.shieldTimer - 0.6);
                    player.vel.multiplyScalar(-0.25);
                    if (Math.random() < 0.25) { scene.remove(ob.mesh); obstacles.splice(i,1); }
                  } else {
                    player.vel.multiplyScalar(-0.45);
                    self.lives -= 0.5;
                    if (Math.random() < 0.3) { scene.remove(ob.mesh); obstacles.splice(i,1); }
                    if (self.lives <= 0) { self.gameOver = true; self.running = false; }
                  }
                }
              }

              // shield timer decay
              if (self.shieldActive) {
                self.shieldTimer -= dt;
                if (self.shieldTimer <= 0) { self.shieldActive = false; self.shieldTimer = 0; }
              }

              // camera follow (subtle)
              camera.position.x += (player.pos.x*0.06 - camera.position.x) * 0.12;
              camera.position.z += (player.pos.z*0.02 - camera.position.z) * 0.02;
              camera.lookAt(player.pos.x*0.5, player.pos.y, player.pos.z - 12);

              // spin effect
              player.mesh.rotation.x += player.vel.z * 0.01;
              player.mesh.rotation.z += player.vel.x * 0.01;
            }

            renderer.render(scene, camera);
            requestAnimationFrame(tick);
          }

          lastTime = performance.now();
          requestAnimationFrame(tick);

          window.addEventListener('resize', ()=>{
            const w = Math.min(window.innerWidth, 900);
            const h = window.innerHeight;
            renderer.setSize(w,h);
            camera.aspect = w/h;
            camera.updateProjectionMatrix();
          });
        } // end initThreeGame
      },
      mounted() {
        // wait for user to press start; but prepare joystick even before start (so knob element exists)
        const self = this;
        // ensure knob exists after Vue renders
        setTimeout(()=>{
          // attach joystick handlers (they will use inputX/inputZ)
          // but real setup happens inside initThreeGame
        }, 120);

        // when started true, init three and joystick
        this.$watch = (key, cb) => {
          // tiny watcher for started
          let old = this.started;
          setInterval(()=>{
            if (this.started && !old) { old = true; cb(); }
          }, 100);
        };
        this.$watch('started', ()=>{
          // init three game after small delay so DOM elements (knob) exist
          setTimeout(()=>{
            // Setup joystick DOM handlers
            const setupKnob = () => {
              const knob = document.getElementById('knob');
              if (!knob) { setTimeout(setupKnob, 80); return; }
              // init three inside Vue method
              this.initThreeGame();
              // call the joystick setup inside the three init (it searches knob element)
            };
            setupKnob();
          }, 160);
        });
      }
    }).mount('#app');
  } // end initApp
  </script>
</body>
</html>
